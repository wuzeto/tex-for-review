\documentclass[UTF8]{ctexart}
\usepackage{amsmath, amssymb}
\usepackage{enumitem}
\usepackage{tasks}
\usepackage{graphicx}
\usepackage[a4paper, margin=0.6in]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{ulem}  % 用于可能的下划线等，这里用于“最深层循环中的语句”等强调（若需要）
\title{数据结构-概念}
\author{NgChakTung}
\date{\today}
\begin{document}
	\maketitle
	\centering
	\includegraphics[totalheight=0.5\textwidth]{2001.png}
	% 使用 enumerate 环境列出题目（可根据需要调整缩进和编号格式）

\section{}
\begin{enumerate}
% 第一部分：线性表、栈、队列操作特性
\item[3] 当向一个顺序表插入一个元素时，从插入位置开始向后的所有元素均需 A 一个位置，移动过程是从 B 向 C 依次移动每一个元素；当从一个顺序表删除一个元素时，被删除元素之后的所有元素均需 D 一个位置，移动过程是从 E 向 F 依次移动每一个元素。

\item[4] 对于长度为 $n$ 的顺序表，插入或删除元素的时间复杂度为 A；对于顺序栈或队列，插入或删除元素的时间复杂度为 B。

\item[5] 线性表、栈和队列都是 A 结构，可以在线性表的 B 位置插入和删除元素；对于栈只能在 C 插入和删除元素；对于队列，只能在 D 插入元素和在 E 删除元素。

\item[6] 栈的插入和删除只能在栈顶一端进行，后进栈的元素必定先被删除，所以又把栈称作 A 表；队列的插入和删除分别在两端进行，进行插入的一端叫做 B，进行删除的一端叫做 C，先进队的元素必定先出队，所以又把队列称作 D 表。

\item[7] 在具有 $n$ 个单元、顺序存储的循环队列中，队满时共有 A 个元素。

\item[8] 向顺序表中第 $i$ 个元素之前插入一个新元素时，首先从 A 开始向后的所有元素均要 B 一个位置，接着把新元素写入 C 上，最后使线性表的长度 D。

\item[9] 从顺序表中删除第 $i$ 个元素时，首先把第 $i$ 个元素赋给 A 带回，接着从 B 开始向后的所有元素均 C 一个位置，最后使线性表的长度 D。

\item[10] 向顺序栈中插入新元素的过程分为三步：第一步是进行 A 判断，判断条件为 B；第二步是修改 C，即把 D 的值赋给 S.top；第三步是把新元素赋给 E。

\item[11] 从顺序栈中删除元素的过程分为三步：第一步是进行 A 判断，判断条件为 B；第二步是把 C 的值赋给变参或函数名带回；第三步是 D，即把 E 的值赋给 S.top。

\item[12] 向顺序存储的循环队列中插入一个元素的过程分为三步：第一步是进行 A 判断，判断条件为 B；第二步是 C，即把 D 的值赋给 Q.r；第三步是把新元素赋给 E。

% 第四部分：线性表存储结构
\item[9] 对于线性表的顺序存储，需要预先分配好存储空间，若分配太多则容易造成存储空间的 A，若分配太少又容易在算法中造成 B，因此适应于数据量变化不大的情况；对于线性表的链接存储（假定采用动态结点），不需要 C 存储空间，存储器中的整个 D 都可供使用，分配和回收结点都非常方便，能够有效地利用存储空间，在算法中不必考虑 E 的发生，因此适应数据量变化较大的情况。

\item[10] 当对一个线性表经常进行的是存取操作，而很少进行插入和删除操作时，则采用 A 存储结构为宜；相反，当经常进行的是插入和删除操作时，则采用 B 存储结构为宜。

\item[11] 无论对于顺序存储还是链接存储的栈和队列来说，进行插入或删除运算的时间复杂性均相同，则为 A。

% 第二部分：算法编写
\item 编写下列算法：
\begin{enumerate}
	\item 向类型为 list 的线性表 L 的第 $i$ 个元素 ($0 \leqslant i \leqslant \text{L.len}$) 之后插入一个新元素 x。
	\item 从类型为 list 的线性表 L 中删除其值等于 x 的所有元素。
	\item 将两个有序表 A 和 B 合并成一个有序表 C，其中 A、B、C 均为 list 类型的变参。
	\item 根据一维数组 A[1..n] 中的 $n$ 个元素建立一个类型为 list 的有序表 L，允许调用本章 2.2 节中的例 2-4 算法。
\end{enumerate}

\item 编写下列算法，假定单链表的表头指针用 HL 表示，类型为 linklist：
\begin{enumerate}
	\item 将一个单链表中的所有结点按相反次序链接。
	\item 删除单链表中第 $i$ 个 ($i \geqslant 1$) 结点。
	\item 删除单链表中由指针 p 所指向的结点。
	\item 从带有附加表头结点的循环单链表中删除其值等于 x 的第一个结点。
	\item 在单链表中指针 p 所指结点之前插入一个值为 x 的新结点。
	\item 从循环单链表中查找出最小值。
	\item 根据一维数组 A(1:n) 中顺序存储的具有 $n$ 个元素的线性表建立一个带有附加表头结点的单链表。
\end{enumerate}

\item[6] 假定用一个循环单链表表示队列（称此为循环链队），该队列只设一个队尾指针，不设队首指针，试编写下列算法：
\begin{enumerate}
	\item 向循环链队插入一个元素为 x 的结点；
	\item 从循环链队中删除一个结点（假定不需要保留被删除结点的值和不需要回收结点）。
\end{enumerate}

\end{enumerate}
\section{}
\begin{enumerate}
	
	\item[8] 编写下列算法（假定所用的字符串均为 pstring 类型，参数 ch、ch1、ch2 均为字符型）：
	\begin{enumerate}
		\item 将字符串 R 中所有其值为 ch1 的字符换成 ch2 的字符。
		\item 将字符串 R 中的所有字符按照相反的次序仍存放在 R 中。
		\item 从字符串 R 中删除其值等于 ch 的所有字符。
		\item 从字符串 r1 中第 $i$ 个字符起求出首次与字符串 r2 相同的子串的起始位置。
		\item 从字符串 R 中删除所有与字符串 r3 相同的子串（允许调用此题的算法 (4) 和 2.6 节中的删除子串算法）。
	\end{enumerate}
	
\end{enumerate}
\section{}
\begin{enumerate}
	% 第三部分：树结构与二叉树特性
\item[2] 假定一棵树的广义表表示为 A(B(E), C(F(H, I, J), G)D)，则该树的度为 A，树的深度为 B，终端结点的个数为 C，单分支结点的个数为 D，双分支结点的个数为 E，三分支结点的个数为 F，C 结点的双亲结点为 G 结点，C 结点的孩子结点为 H 和 I 结点。

\item[7] 在一棵具有 $n$ 个结点的完全二叉树中，若编号为 $i$ 的结点有左孩子，则左孩子结点的编号为 A；若有右孩子，则右孩子结点的编号为 B；若有双亲结点，则当 $i$ 为偶数时，双亲结点的编号为 C，当 $i$ 为奇数时，双亲结点的编号为 D。

\item[8] 在二叉树的顺序存储中，对于下标为 5 的结点，它的父母结点的下标为 A，若它存在左子女，则左子女结点的下标为 B，若它存在右子女，则右子女结点的下标为 C。

\item[9] 对于一棵具有 $n$ 个结点的二叉树，当进行链接存储时，其存储映象中的指针域的总数为 A 个，其中 B 个用于链接孩子结点，C 个空闲着。

\item[10] 假定一棵二叉树的广义表表示为 A(B(D), C(E(G), F))，则该树的深度为 A，度为 0 的结点数为 B，度为 1 的结点数为 C，度为 2 的结点数为 D；C 结点是 A 结点的 E 孩子，E 结点是 C 结点的 F 孩子。

\item[11] 对于一个具有 $n$ 个结点的二叉树，当它为一棵 A 二叉树时具有最小高度；即为 B，当它为一棵单支树时具有 C 高度，即为 D。

\end{enumerate}
\section{}
\begin{enumerate}
	% 第一部分：排序算法选择
	\item[8] 在堆排序和快速排序中，若原始记录接近正序或反序，则选用 A，若原始记录无序，则最好选用 B。
	
	\item[9] 在直接插入和直接选择排序中，若初始数据基本正序，则选用 A，若初始数据基本反序则选用 B。
	
	\item[10] 在堆排序、快速排序和归并排序中，若只从节省存储空间考虑，则应首先选取 A 方法，其次选取 B 方法，最后选取 C 方法；若只从排序结果的稳定性考虑，则应选取 D 方法；若只从平均情况下排序最快考虑，则应选取 E 方法；若只从最坏情况下排序最快并且要节省内存考虑，则应选取 F 方法。
	
	% 第二部分：查找方法与时间复杂度
	\item[4] 在索引查找或分块查找中，首先查找 A，然后再查找相应的 B，整个索引查找的平均查找长度等于查找索引表的平均查找长度与查找相应子表的平均查找长度之 C。
	
	\item[6] 对于长度为 $n$ 的线性表，若进行顺序查找，则时间复杂性为 A，若进行二分查找，则时间复杂性为 B，若进行分块查找（假定总块数和每块长度均接近 $\sqrt{n}$ 的值），则时间复杂性为 C。
	
	\item[7] 若一个待散列存储的线性表长度为 $n$，用于散列的散列表长度为 $m$，则 $m$ 应 A $n$，装填因子 $\alpha$ 为 B。
	
	\item[8] 在散列存储中，装填因子 $\alpha$ 的值越大，存取元素时发生冲突的可能性就 A，当 $\alpha$ 的值越小，存取元素时发生冲突的可能性就 B。
	
	\item[9] 在线性表的散列存储中，处理冲突有 A 和 B 两类；当装填因子一定时，采用链接法处理冲突比采用开放定址法处理冲突的平均查找长度要 C。
	

	
\end{enumerate}


\end{document}